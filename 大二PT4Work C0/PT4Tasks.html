<!-- Programming Taskbook 4.23 | Copyright (c) M. Abramyan, 1998-2022 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:5px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:5px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;margin-top:5px; }
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;margin-top:0px;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;margin-top:0px;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Functions</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2022</p>
<p class="ptComment"> The additional ZFunc group, unlike the standard Proc and Func groups, is available for all languages supported by the taskbook. If the Func group is available for a language, the ZFunc group coincides with the Func group for this language; if the Proc group is available for a language, the ZFunc group contains the Proc group tasks in modified order: first Proc16&#8211;36, then Proc1&#8211;15, then the remaining tasks. Thus, each ZFunc task for any language is related to the development of the <i>same</i> function (although the formulation of the task for different languages may be different).</p>
<h2>Procedures with numeric parameters</h2>
<p class="ptTask"><span class="ptSpecial">ZFunc26</span>. Write a procedure RectPS(<i>x</i><sub>1</sub>,&nbsp;<i>y</i><sub>1</sub>,&nbsp;<i>x</i><sub>2</sub>,&nbsp;<i>y</i><sub>2</sub>,&nbsp;<i>P</i>,&nbsp;<i>S</i>) that computes the perimeter&nbsp;<i>P</i> and the area&nbsp;<i>S</i> of a rectangle whose opposite vertices have coordinates (<i>x</i><sub>1</sub>,&nbsp;<i>y</i><sub>1</sub>) and (<i>x</i><sub>2</sub>,&nbsp;<i>y</i><sub>2</sub>) and sides are parallel to coordinate axes (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>y</i><sub>2</sub> are input parameters, <i>P</i> and&nbsp;<i>S</i> are output parameters, all parameters are the real-valued ones). Using this procedure, find the perimeters and the areas of three rectangles with the given opposite vertices. </p>
<h1>One-dimensional arrays</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2019</p>
<h2>One-dimensional arrays: series of&nbsp;equal numbers</h2>
<p class="ptTask"><span class="ptSpecial">ZArray123</span>. An integer&nbsp;<i>K</i> (&#8805;&nbsp;1) and an array of <i>N</i>&nbsp;integers are given. Exchange the first and the <i>K</i>-th series of equal numbers of the array (see the <i>series</i> definition in ZArray116, series are numbered from&nbsp;0). If the array contains less than <i>K</i>&nbsp;+&nbsp;1 series, then do not change it. </p>
<h1>Two-dimensional arrays (matrices)</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2019</p>
<h2>Two-dimensional arrays (matrices): diagonals</h2>
<p class="ptTask"><span class="ptSpecial">ZMatrix98</span>. A real-valued square matrix&nbsp;<i>A</i> of order&nbsp;<i>M</i> is given. Rotate its elements by 180&#176; (that is, exchange values of matrix elements&nbsp;<i>A</i><sub>0,0</sub> and&nbsp;<i>A</i><sub><i>M</i>&#8722;1,<i>M</i>&#8722;1</sub>, <i>A</i><sub>0,1</sub> and&nbsp;<i>A</i><sub><i>M</i>&#8722;1,<i>M</i>&#8722;2</sub>, and so on). Do not use an additional matrix. </p>
<h1>Characters and&nbsp;strings</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2007, 2012</p>
<h2>Characters and&nbsp;strings: basic operations</h2>
<p class="ptComment"> All input strings are assumed to contain no <i>overlapping</i> occurrences of a required substring in the tasks connected with search and replacement. Furthermore, substring removing (in String32 and String35) or substring replacement (in String38) do not lead to <i>new</i> occurrences of this substring in the given string.</p>
<p class="ptTask"><span class="ptSpecial">String12</span>. Given a nonempty string and an integer&nbsp;<i>N</i> (&gt;&nbsp;0), output a new string that contains the given string characters separated by <i>N</i>&nbsp;characters &#34;*&#34;. </p>
<p class="ptTask"><span class="ptSpecial">String21</span>. Given a positive integer, output all digit characters in the decimal representation of the integer (from right to left). </p>
<p class="ptTask"><span class="ptSpecial">String33</span>. Two strings&nbsp;<i>S</i>, <i>S</i><sub>0</sub> are given. Remove the first occurrence of&nbsp;<i>S</i><sub>0</sub> from the string&nbsp;<i>S</i>. If the string&nbsp;<i>S</i> does not contain required substrings then do not change it. </p>
<h2>Characters and&nbsp;strings: additional tasks</h2>
<p class="ptTask"><span class="ptSpecial">String61</span>. A string that contains a <i>fully qualified path name</i> (that is, the drive and directory parts, the file name and extension) is given. Extract the last directory name (without backslashes &#34;\&#34;) from the string. If the file with the given name is located in the root directory then output a backslash. </p>
<h1>Binary files</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2007, 2012</p>
<p class="ptComment"> The <i>binary file</i> is a file that contains elements of the same type in the binary format. </p><p class="ptComment">In C++, binary files should be opened in the <tt>ios_base::binary</tt> mode; the read and write operations for binary files are implemented by the <tt>read</tt> and <tt>write</tt> methods with the <tt>((char *)&amp;x, sizeof(x))</tt> parameters, where the <tt>x</tt> variable has a type that matches the type of file elements. </p><p class="ptComment">The condition &#34;A file of integers (real numbers, characters, strings) is given&#34; means that the <i>file name</i> is given (as a string input data) and the corresponding file exists and is located in the working directory. In some tasks it is necessary to check the file existence; this task condition is pointed out explicitly. File components must be read using standard input procedures (or functions) of the programming language being used. </p><p class="ptComment">If the task requires to create a new file then the new file name is included in the input data set; this name is usually the last element of input data. Standard output procedures (or functions) of the programming language must be used for writing data to files. </p><p class="ptComment">The <i>size of a typed file</i> always means the amount of <i>file components</i> of the corresponding type. File components are assumed to be numbered beginning with&nbsp;1. </p><p class="ptComment">The minimal size of any input file is assumed to be&nbsp;2 (that is, any file contains at least two components), if the task does not specify it explicitly. The maximal file size is not fixed, so auxiliary <i>arrays</i> should not be used to store all file components but one may use temporary <i>files</i>.</p>
<h2>Binary files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">File32</span>. Given a file of integers that contains an even number of components, remove the first half of the file components. </p>
<h2>Work with several numeric files. Archival files</h2>
<p class="ptTask"><span class="ptSpecial">File57</span>. Two strings&nbsp;<i>S</i><sub>1</sub>, <i>S</i><sub>2</sub> and an <i>archival file</i> are given. The archival file contains data of several files; the format of archival file is described in File55. Create two new files called&nbsp;<i>S</i><sub>1</sub>, <i>S</i><sub>2</sub>; the first resulting file must contain first components of all files, which are contained in the archival file, the second resulting file must contain last components of all files, which are contained in the archival file. </p>
<h1>Text files</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2007, 2012</p>
<p class="ptComment"> The condition &#34;A text file is given&#34; means that the <i>file name</i> is given (as a string input data) and the corresponding file exists and is located in the working directory. File components (as a rule, lines of characters) must be read using standard input procedures (or functions) of a programming language being used. </p><p class="ptComment">If the task requires to create a new file then the new file name is included in the input data set; this name is usually the last element of input data. Standard output procedures (or functions) of the programming language must be used for writing data to files. </p><p class="ptComment">The size of any input file is not fixed, so additional <i>arrays</i> should not be used to store all file components but one may use temporary <i>files</i>. </p><p class="ptComment">Binary files may also be used in the tasks of &#34;Text files&#34; group; see the beginning of the section &#34;Binary files&#34; for additional rules connected with files of this kind.</p>
<h2>Text files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">Text8</span>. Given two text files, add the contents of the second file to the beginning of the first one. </p>
<h2>Text files with numeric data</h2>
<p class="ptComment"> The decimal separator in string representation of any real number with nonzero fractional part is assumed to be the <i>decimal point</i> &#34;.&#34; in all tasks of this subsection.</p>
<p class="ptTask"><span class="ptSpecial">Text45</span>. A text file is given. Each line of the file represents an integer or real number padded by several leading and trailing blank characters. All real numbers have nonzero fractional part. Output the amount and sum of numbers with nonzero fractional part. </p>
<h1>Recursion</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2007, 2012</p>
<h2>Recursion: simple algorithms</h2>
<p class="ptComment"> It should be noted that all tasks of this subsection can be solved by means of simple iterative algorithms without using of recursion; moreover, in some cases using of recursion leads to inefficient algorithms (see Recur4 and Recur6). Nevertheless, tasks of such a kind allow to receive easily an initial experience in developing of recursive algorithms.</p>
<p class="ptTask"><span class="ptSpecial">Recur10°</span>. Write a recursive integer function DigitSum(<i>K</i>) that returns the sum of digits of an integer&nbsp;<i>K</i> (the loop statements should not be used). Using this function, output the sum of digits for each of five given integers. </p>
<h2>Recursion: parsing of&nbsp;expressions</h2>
<p class="ptComment"> Input strings are assumed to contain no blank characters in all tasks of this subsection. </p><p class="ptComment">The loop statements should not be used for solving these tasks.</p>
<p class="ptTask"><span class="ptSpecial">Recur17°</span>. Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;expression&gt;&lt;operator&gt;&lt;expression&gt;)<tr><td align=left>&lt;operator&gt;   <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p>
<h2>Recursion: backtracking</h2>
<p class="ptTask"><span class="ptSpecial">Recur29</span>. A tree of depth&nbsp;<i>N</i> is given. Each internal node of the tree has three children; the left child&nbsp;&#34;A&#34; with the weight&nbsp;1, the middle child&nbsp;&#34;B&#34; with the weight&nbsp;0, the right child&nbsp;&#34;C&#34; with the weight&nbsp;&#8722;1. The tree root&nbsp;&#34;D&#34; has the weight&nbsp;0. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy two additional conditions: the total weight of any initial part of the path nodes is nonnegative, and the total weight of all path nodes equals&nbsp;0. The order of paths must be the same as in Recur25. </p>
<h1>Dynamic data structures (based on&nbsp;pointers)</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2007, 2012</p>
<p class="ptComment"> All numbers mentioned in tasks of this group are of integer type. All pointers are of PNode type; they point to records of TNode type. In the tasks of this group the Data, Next, and Prev fields of the TNode record are used, therefore one can assume that the PNode and TNode types are defined as follows: </p><p class="ptComment">[Pascal] </p><p class="ptCommentQuote"><tt>type</tt><br> &nbsp; &nbsp;<tt>PNode = ^TNode;</tt><br> &nbsp; &nbsp;<tt>TNode = record</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Data: integer;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Next: PNode;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Prev: PNode;</tt><br> &nbsp; &nbsp;<tt>end;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[C/C++] </p><p class="ptCommentQuote"><tt>struct TNode</tt><br><tt>{</tt><br> &nbsp; &nbsp;<tt>int Data;</tt><br> &nbsp; &nbsp;<tt>TNode* Next;</tt><br> &nbsp; &nbsp;<tt>TNode* Prev;</tt><br><tt>};</tt><br><tt>typedef TNode* PNode;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">In the introductory tasks and in the tasks devoted to <i>stacks</i> and <i>queues</i> only the Data and Next fields of the TNode record are used. In the tasks devoted to <i>lists</i> all fields (Data, Next, Prev) of the TNode record are used. </p><p class="ptComment">Words &#34;pointer&#34; (to some data) and &#34;address&#34; (of some data) are used as synonyms since variables of pointer type are intended for storing <i>addresses</i>. </p><p class="ptComment">The order number of the first node of a list is assumed to be equal to&nbsp;1. </p><p class="ptComment">In C/C++ programs the DeleteNode(p) function call (of, in C++, the delete&nbsp;p operator) should be used to free the memory that a pointer p (of the PNode type) addresses.</p>
<h2>Dynamic data structures: stack</h2>
<p class="ptComment"> In these tasks a <i>stack</i> structure is implemented by a chain of linked components (<i>nodes</i>) of TNode type. The Next field of the last node equals NULL. The first node is said to be a <i>top</i> of the stack. The pointer to the top of the stack provides access to the stack data (if the stack is empty then this pointer equals NULL). The value of the Data field of a stack component is considered as the <i>value of this component</i>.</p>
<p class="ptTask"><span class="ptSpecial">Dynamic4</span>. An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Create a stack that contains <i>N</i>&nbsp;components with the given values (a component with the last value must be the top of the stack) and output a pointer to the top of the stack. </p>
<h2>Dynamic data structures: queue</h2>
<p class="ptComment"> In these tasks a <i>queue</i> structure is implemented by a chain of linked components (<i>nodes</i>) of TNode type. The Next field of the last node equals NULL. The first node is said to be a <i>head</i> of the queue; the head is located at the <i>front</i> of the queue. The last node is said to be a <i>tail</i> of the queue; the tail is located at the <i>end</i> of the queue. It is convenient to store not only a pointer to the queue head but also a pointer to the queue tail because it accelerates adding a new component to the end of a queue. If a queue is empty then these pointers equal NULL. The value of the Data field of a queue component is considered as the <i>value of this component</i>.</p>
<p class="ptTask"><span class="ptSpecial">Dynamic19</span>. An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a nonempty queue are given. Remove <i>N</i>&nbsp;initial components from the queue and output their values (if the queue contains less than <i>N</i>&nbsp;components then remove all its components). Also output the new addresses of the head and tail of the queue (if the resulting queue will be empty then output NULL twice). After removing components release the memory allocated for them. </p>
<p class="ptTask"><span class="ptSpecial">Dynamic26</span>. Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given (if the queue is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TQueue that is a record with two fields, <i>Head</i> and <i>Tail</i>, of PNode type (the fields refer to the head and tail of a queue respectively). Also write a procedure Enqueue(<i>Q</i>,&nbsp;<i>D</i>) that adds a new component with the value&nbsp;<i>D</i> to the end of a queue&nbsp;<i>Q</i> (a record&nbsp;<i>Q</i> of TQueue type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). Using this procedure, add all elements of the given sequence to the end of the given queue. Output the new addresses of the head and tail of the queue. </p>
<h2>Dynamic data structures: doubly linked list</h2>
<p class="ptComment"> In these tasks a <i>doubly linked list</i> structure is implemented by a chain of components (<i>nodes</i>) of TNode type; these nodes are linked with both the next node and the previous one. The Next field of the last node and the Prev field of the first node are equal to NULL. Though storing of address of some list node is sufficient to provide access to any list node, it is convenient to store <i>three</i> pointers (to the <i>first</i>, <i>last</i>, and <i>current</i> list node) because they accelerate list operations. If a list is empty then these pointers equal NULL. The value of the Data field of a list component is considered as the <i>value of this component</i>.</p>
<p class="ptTask"><span class="ptSpecial">Dynamic31</span>. A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Output the amount&nbsp;<i>N</i> of the list components and also pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component respectively. </p>
<p class="ptTask"><span class="ptSpecial">Dynamic57</span>. An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a nonempty doubly linked list are given. Perform a <i>cyclic shift</i> of all list components by <i>K</i>&nbsp;positions forward (that is, from the beginning toward the end of the list). Output the addresses of the first and last component of the resulting list. The required shift should be performed as follows: transform the given list to the circular one (see Dynamic55) and then break this circular list at the position that corresponds to the given value of&nbsp;<i>K</i>. Do not use operations of allocating and freeing memory. </p>
<h2>Dynamic data structures: list with the&nbsp;barrier component</h2>
<p class="ptComment"> In these tasks a <i>doubly linked list</i> structure is implemented by a <i>circular</i> doubly linked chain of nodes with an additional <i>barrier node</i> (the <i>barrier component</i> of a list). This barrier node is linked with the first and last &#34;true&#34; list component by the Next and Prev field respectively; similarly, the first/last &#34;true&#34; list component is linked with the barrier node by the Prev/Next field respectively. Such a list implementation allows to store only <i>two</i> pointers (to the barrier and current list component) for list processing. The <i>Data</i> field of the barrier component may be of any value; for definiteness the value of this field is considered to equal zero. Both some &#34;true&#34; list component and the barrier component may be the current component. An <i>empty</i> list in this implementation is represented as a single barrier node <i>linked with itself</i>; the current component of an empty list is always the barrier component.</p>
<p class="ptTask"><span class="ptSpecial">Dynamic78°</span>. Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Using the TListB type (see Dynamic74), write three procedures: a procedure LBToFirst(<i>L</i>) makes the first component of a list&nbsp;<i>L</i> the current one; a procedure LBToNext(<i>L</i>) makes the component, which follows the current component of a list&nbsp;<i>L</i>, the new current one; a procedure LBSetData(<i>L</i>,&nbsp;<i>D</i>) assigns a new integer value&nbsp;<i>D</i> to the current component of a list&nbsp;<i>L</i> (provided that the current component is not the barrier one). Also write a logical function IsBarrier(<i>L</i>) that returns true if the current component of a list&nbsp;<i>L</i> is the barrier component, and false otherwise. A record&nbsp;<i>L</i> of TListB type is an input and output parameter of the LBToFirst and LBToNext procedure and is an input parameter of the LBSetData procedure and the IsBarrier function. Using these procedures and function, assign zero value to the list components with odd order numbers. Output the amount of list components and the address of the current component of the resulting list (the current component should be the barrier one). The components are numbered from the first component, which has the order number&nbsp;1; the barrier component is not numbered and should not be counted. </p>
<h1>Trees (based on&nbsp;pointers)</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2008, 2012</p>
<p class="ptComment"> All numbers mentioned in the tasks of this group are of integer type. All pointers are of PNode type; they point to records of TNode type. In the tasks of this group the Data, Left, Right, and Parent fields of the TNode record are used, therefore one can assume that the PNode and TNode types are defined as follows: </p><p class="ptComment">[Pascal] </p><p class="ptCommentQuote"><tt>type</tt><br> &nbsp; &nbsp;<tt>PNode = ^TNode;</tt><br> &nbsp; &nbsp;<tt>TNode = record</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Data: integer;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Left: PNode;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Right: PNode;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Parent: PNode;</tt><br> &nbsp; &nbsp;<tt>end;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[C/C++] </p><p class="ptCommentQuote"><tt>struct TNode</tt><br><tt>{</tt><br> &nbsp; &nbsp;<tt>int Data;</tt><br> &nbsp; &nbsp;<tt>TNode* Left;</tt><br> &nbsp; &nbsp;<tt>TNode* Right;</tt><br> &nbsp; &nbsp;<tt>TNode* Parent;</tt><br><tt>};</tt><br><tt>typedef TNode* PNode;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">In the most of the tasks only the Data, Left, and Right fields of the TNode record are used. The Parent field is required in the tasks devoted to doubly linked trees. </p><p class="ptComment">The value of the Data field of a variable of TNode type is considered as the <i>value of the corresponding tree node</i>. </p><p class="ptComment">In C/C++ programs the DeleteNode(p) function call (or, in C++, the delete&nbsp;p operator) should be used to free the memory that a pointer p (of the PNode type) addresses.</p>
<h2>Binary trees: analysis</h2>
<p class="ptTask"><span class="ptSpecial">Tree7</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty tree is given. Output the sum of values of all tree leaves. </p>
<p class="ptTask"><span class="ptSpecial">Tree24</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty tree is given. Using inorder tree walk, find the last node with the maximal odd value and output its address&nbsp;<i>P</i><sub>2</sub>. If the tree does not contain nodes with odd values then output NULL. </p>
<h2>Binary trees: creation</h2>
<p class="ptTask"><span class="ptSpecial">Tree33</span>. An integer&nbsp;<i>N</i> (&gt;&nbsp;0) is given. Create a balanced tree with <i>N</i>&nbsp;nodes and output the address of the tree root. The value of each node should be equal to its level (for example, the root value is&nbsp;0, the value of its children is&nbsp;1, and so&nbsp;on). Create the balanced tree by means of the recursive algorithm described in Tree32. </p>
<h2>Binary trees: changing</h2>
<p class="ptTask"><span class="ptSpecial">Tree42</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty tree is given. Remove all nodes whose value is less than the root value, together with all their descendants. Release the memory allocated for removed nodes. </p>
<h2>Doubly linked binary trees</h2>
<p class="ptTask"><span class="ptSpecial">Tree50</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to some node of a doubly linked tree is given. Output the pointer&nbsp;<i>P</i><sub>2</sub> to the tree root. </p>
<h2>Binary search trees</h2>
<p class="ptTask"><span class="ptSpecial">Tree57</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty tree is given. It the tree is <i>a search tree</i>, that is, values of its nodes form a non-decreasing sequence in inorder tree walk, then output NULL; otherwise output the address of the first node (in inorder tree walk) that breaks the search-tree property. </p>
<p class="ptTask"><span class="ptSpecial">Tree67</span>. Two pointers are given: <i>P</i><sub>1</sub> to the root of a nonempty search tree and&nbsp;<i>P</i><sub>2</sub> to one of its nodes with no more than one child. Remove the node&nbsp;<i>P</i><sub>2</sub> from the tree so that the tree still remains a search tree (if the node&nbsp;<i>P</i><sub>2</sub> has a child then link the child with the parent of the node&nbsp;<i>P</i><sub>2</sub>). If the resulting tree is not empty then output the pointer&nbsp;<i>P</i><sub>3</sub> to its root, otherwise output NULL. </p>
<h2>Binary parse trees</h2>
<p class="ptTask"><span class="ptSpecial">Tree81</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty parse tree is given. Output the string representation of expression that corresponds to the given tree. Use the parenthesis-free preorder format (see Tree77). </p>
<h2>General trees</h2>
<p class="ptTask"><span class="ptSpecial">Tree91</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty general tree and an integer&nbsp;<i>L</i> (&#8805;&nbsp;0) are given. Output the values of nodes of the level&nbsp;<i>L</i> and their amount&nbsp;<i>N</i> (nodes must be ordered from left to right). If nodes of the level&nbsp;<i>L</i> are absent then output&nbsp;0. </p>
<p class="ptTask"><span class="ptSpecial">Tree94</span>. A pointer&nbsp;<i>P</i><sub>1</sub> to the root of a nonempty general tree and an integer&nbsp;<i>N</i> (&#8805;&nbsp;0) are given. Output the amount of nodes that have exactly <i>N</i>&nbsp;child nodes (this amount may be equal to&nbsp;0). </p>
<hr noshade>
<p class="ptFooter">Page generation date: 2023/2/16.</p>
</body></html>
